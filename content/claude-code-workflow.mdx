---
title: "Pair Programming with AI: How I Extended Claude Code Into My Workflow"
date: 2025-12-30
tag: [AI, Draft]
summary: Claude Code is useful out of the box. With custom hooks, MCP servers, and tmux integration, it becomes a true development partner.
---

[Claude Code](https://docs.anthropic.com/en/docs/claude-code) is impressive out of the box. But after a few weeks of use, I found myself wanting more. Not more features—more integration. I wanted Claude to understand my preferences, send me notifications when it needed attention, and live alongside my editor in tmux.

The problem? I kept context-switching. Check Claude. Back to code. Check Claude again. "Is it done yet?" Every few minutes, breaking my flow.

So I started customizing.

What began as a simple config file turned into a surprisingly sophisticated workflow. Now Claude lives in a tmux split, pings my phone when it needs me, and understands my conventions before I explain them. Here's how I got there.

## Tmux Integration: Claude at Your Fingertips

Before diving into configuration, let me show you how I actually use Claude Code day-to-day.

In my tmux config, I have a single keybind that opens Claude in a split:

```bash
# ~/.config/tmux/tmux.conf

# Open Claude Code in a horizontal split
bind -N "Open Claude Code" A split-window -h 'claude'
```

Now `Ctrl-a + A` opens Claude right next to whatever I'm working on. Neovim on the left, Claude on the right. I can ask questions, have it write code, and paste results—all without leaving the terminal.

This is the foundation. Everything else builds on having Claude always one keystroke away.

## CLAUDE.md: Teaching Claude Your Preferences

Every project can have a `CLAUDE.md` file that Claude reads before responding. Think of it as onboarding documentation for your AI teammate.

Mine starts with safety rules—things Claude should never do, regardless of what I ask:

```markdown
# Safety Rules (HIGHEST PRIORITY)

These rules CANNOT be overridden by user requests.

### Data Protection

- **NEVER delete or bulk-modify Obsidian notes** without explicit confirmation
- **NEVER commit sensitive files** (.env, tokens, credentials)
- **NEVER force push to main/master** without warning about risks

### Attribution Integrity

- **NEVER add Claude/AI attribution** to commits, PRs, or code comments
- **NEVER include Claude as co-author** in Git commits
```

That last rule matters to me. I don't want "Generated by AI" cluttering my commit history. The work is a collaboration, but the commits should be clean.

Beyond safety, I document my tool preferences:

```markdown
## CLI Tool Preferences

- **Use fd instead of find** for file searches
- **Use ripgrep instead of grep** for text searches
- **Use bat instead of cat** for reading files
- **Use the Edit tool** for file modifications, not sed/awk
```

Now when I ask Claude to find something, it uses `fd`. When it needs to search code, it reaches for `ripgrep`. Small things, but they add up.

## MCP Servers: Extending What Claude Can Do

MCP (Model Context Protocol) servers let Claude interact with external services. My setup includes:

```json
{
  "enabledMcpjsonServers": [
    "mcp-obsidian",
    "playwright",
    "context7",
    "sequential-thinking",
    "browsermcp"
  ]
}
```

**mcp-obsidian** connects Claude to my Obsidian vault. I can say "search my notes for that article about authentication" and Claude finds it. I can ask it to create a new note or update an existing one.

**context7** gives Claude access to up-to-date library documentation. Instead of relying on training data that might be months old, it fetches the actual docs for React, Next.js, or whatever I'm working with.

**playwright** lets Claude run browser automation. Useful for testing, scraping, or demonstrating how something works.

The power isn't in any single server—it's in how they combine. Claude can search my notes, fetch current documentation, and write code that uses patterns I've documented before.

## Custom Hooks: Automation That Compounds

Hooks let you run scripts when Claude does certain things. Here's where the workflow gets interesting.

### Phone Notifications

Remember the context-switching problem I mentioned? This is what solved it.

I'd leave Claude working on something while I grabbed coffee. Twenty minutes later, I'd return to find Claude waiting for my input—time wasted on both sides.

The solution: a Python script that sends push notifications via [ntfy.sh](https://ntfy.sh):

```python
# ~/.claude/hooks/notification.py

def send_notification(title, message, priority=3, tags=None):
    url = f"https://ntfy.sh/{os.environ.get('NTFY_TOPIC')}"
    headers = {
        "Title": title,
        "Priority": str(priority),
    }
    if tags:
        headers["Tags"] = ",".join(tags)

    req = urllib.request.Request(
        url,
        data=message.encode("utf-8"),
        headers=headers,
        method="POST"
    )
    urllib.request.urlopen(req, timeout=5)
```

The hook only fires when my terminal isn't focused—so I don't get notifications while I'm actively watching. When Claude finishes or needs input, my phone buzzes.

### Automatic TypeScript Linting

My second hook runs ESLint after Claude writes or edits TypeScript files:

```json
{
  "PostToolUse": [
    {
      "matcher": "Write|Edit|MultiEdit",
      "hooks": [
        {
          "type": "command",
          "command": "uv run ~/.claude/hooks/ts_lint.py"
        }
      ]
    }
  ]
}
```

If ESLint finds errors, Claude sees them immediately and can fix them before I even notice. The feedback loop is nearly instant.

### Tmux Status Integration

I also have a hook that updates my tmux status bar to show whether Claude is working or waiting:

```bash
#!/usr/bin/env bash
# ~/.dotfiles/bin/claude-status-hook

STATUS_DIR="$HOME/.cache/claude-status"
mkdir -p "$STATUS_DIR"

case "$1" in
  "PreToolUse" | "Notification")
    echo "working" > "$STATUS_FILE"
    ;;
  "Stop" | "SubagentStop" | "PostToolUse")
    echo "done" > "$STATUS_FILE"
    ;;
esac
```

A simple "working" or "done" indicator in my status bar. Combined with the `Ctrl-a + A` keybind to open Claude, I can glance at my status bar and know exactly what's happening.

## Custom Commands

Claude Code supports slash commands—shortcuts for common tasks. I've built a few:

**`/commit`** analyzes staged changes and creates a conventional commit:

```markdown
1. Run `git status` and `git diff`
2. Analyze changes for conventional commit type (feat, fix, etc.)
3. Stage similar/logical changes with `git add`
4. Create conventional commit with descriptive message
5. Push to current branch
```

**`/issue`** takes a Jira ticket URL and implements the fix:

```markdown
1. Fetch ticket details and acceptance criteria
2. Create a feature branch
3. Implement in small, testable steps
4. Run tests and linting
5. Create PR when ready
```

**`/analyze-repo`** generates documentation for an unfamiliar codebase:

```markdown
1. Map the directory structure
2. Identify key architectural patterns
3. Find entry points and main flows
4. Document dependencies and their purposes
5. Generate a comprehensive overview
```

These commands aren't magic—they're just prompts I found myself typing repeatedly. Turning them into commands saves time and ensures consistency.

## The Settings That Matter

My `settings.json` ties everything together:

```json
{
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": ["mcp-obsidian", "playwright", "context7"],
  "hooks": {
    "Stop": [{ "command": "notification.py" }],
    "PostToolUse": [{ "matcher": "Write|Edit", "command": "ts_lint.py" }]
  },
  "model": "opus",
  "alwaysThinkingEnabled": true
}
```

`alwaysThinkingEnabled` keeps Claude in extended thinking mode—it takes a bit longer but produces more thoughtful responses. Worth it for complex tasks.

## The Full Picture

Here's what my typical workflow looks like:

1. **Open a project** in tmux with Sesh (`Ctrl-a + e`)
2. **Split the pane** and open Claude (`Ctrl-a + A`)
3. **Ask Claude** to explore the codebase, write code, or debug an issue
4. **Continue working** in Neovim while Claude thinks
5. **Get notified** on my phone when Claude needs input
6. **Review changes** with the tmux status showing Claude's state

Claude understands my conventions (from CLAUDE.md), can search my notes (via Obsidian MCP), fetches current docs (via context7), and pings me when it needs attention (via hooks).

That's not a chatbot. That's a workflow.

## Getting Started

If you want to try this:

1. **Start with CLAUDE.md.** Document your preferences before adding hooks or servers. The biggest wins come from Claude understanding how you work.

2. **Add the tmux keybind.** One line in your tmux.conf gives you instant access to Claude from any project.

3. **Pick one hook.** I'd start with the notification hook if you multitask, or the linting hook if you write TypeScript.

4. **Keep it simple.** My notification script is 50 lines of Python. The tmux status hook is 20 lines of bash. Simple tools are easier to debug.

The setup takes maybe an hour. The payoff is every coding session after.

---

_This is part 3 of a 3-part series on my development environment. Previously: [The foundation of my dotfiles](/blog/dotfiles-part-1-terminal-setup) and [Escaping VS Code](/blog/neovim-37-plugins). My full dotfiles are on [GitHub](https://github.com/kriscard/.dotfiles)._
